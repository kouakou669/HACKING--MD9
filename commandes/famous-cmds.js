const { zokou } = require("../framework/zokou");

const axios = require("axios");

const fs = require("fs");

const path = require("path");

// Utilitaires communsü§ü

const utils = {

  validateInput: (input, pattern, errorMsg) => {

    if (!pattern.test(input)) {

      throw new Error(errorMsg);

    }

    return true;

  },

  

  randomFromArray: (arr) => arr[Math.floor(Math.random() * arr.length)],

  

  formatResponse: (title, content) => `üî∞ *${title}*\n\n${content}`

};

// Calculatrice am√©lior√©e

zokou({

  nomCom: "calc",

  categorie: "FAMOUS-TECH-PLUGINSüá≠üáπ",

  reaction: "üßÆ",

  desc: "Calculatrice avanc√©e avec historique.",

  alias: ["calcul"]

}, async (origineMessage, zk, commandeOptions) => {

  const { arg, repondre } = commandeOptions;

  if (!arg[0]) {

    return repondre("‚ùå Veuillez entrer une expression math√©matique.");

  }

  const expression = arg.join(" ");

  

  try {

    utils.validateInput(expression, /^[0-9+\-*/().\ ]+$/, "Expression non valide");

    

    const result = new Function(`return ${expression}`)();

    

    if (!isFinite(result)) {

      throw new Error("R√©sultat invalide (division par z√©ro ou nombre trop grand)");

    }

    const response = utils.formatResponse("Calculatrice", 

      `üìù Expression: ${expression}\n` +

      `üî¢ R√©sultat: ${result}\n` +

      `‚ÑπÔ∏è Type: ${typeof result}`

    );

    repondre(response);

  } catch (error) {

    repondre(`‚ùå Erreur: ${error.message}`);

  }

});

// Dictionnaire am√©lior√©

zokou({

  nomCom: "def",

  categorie: "FAMOUS-TECH-PLUGINSüá≠üáπ",

  reaction: "üìñ",

  desc: "Dictionnaire avanc√© avec exemples et synonymes.",

  alias: ["definition"]

}, async (origineMessage, zk, commandeOptions) => {

  const { arg, repondre } = commandeOptions;

  if (!arg[0]) {

    return repondre("‚ùå Veuillez sp√©cifier un mot √† d√©finir.");

  }

  const mot = arg[0];

  

  try {

    utils.validateInput(mot, /^[a-zA-Z√Ä-√ø-]+$/, "Mot invalide");

    

    const response = await axios.get(`https://api.dictionaryapi.dev/api/v2/entries/fr/${mot}`);

    

    if (!response.data || response.data.length === 0) {

      throw new Error("Aucune d√©finition trouv√©e");

    }

    const data = response.data[0];

    const definitions = data.meanings.map(meaning => ({

      type: meaning.partOfSpeech,

      def: meaning.definitions[0].definition,

      example: meaning.definitions[0].example,

      synonymes: meaning.synonyms?.slice(0, 3)

    }));

    const formattedResponse = utils.formatResponse("Dictionnaire",

      `üìù Mot: ${mot}\n\n` +

      definitions.map(def => 

        `üî§ Type: ${def.type}\n` +

        `üìö D√©finition: ${def.def}\n` +

        (def.example ? `üí° Exemple: ${def.example}\n` : '') +

        (def.synonymes?.length ? `üîÑ Synonymes: ${def.synonymes.join(", ")}\n` : '')

      ).join("\n")

    );

    repondre(formattedResponse);

  } catch (error) {

    repondre(`‚ùå Erreur: ${error.message || "Service indisponible"}`);

  }

});

// G√©n√©rateur de noms am√©lior√©

zokou({

  nomCom: "namegen",

  categorie: "FAMOUS-TECH-PLUGINSüá≠üáπ",

  reaction: "üë§",

  desc: "G√©n√®re des noms cr√©atifs avec personnalisation.",

  alias: ["genname"]

}, async (origineMessage, zk, commandeOptions) => {

  const { arg, repondre } = commandeOptions;

  const categories = {

    fantasy: {

      prefixes: ["Aether", "Celestia", "Dragon", "Eldar", "Frost", "Galen", "Hyper", "Iron", "Jade", "Kael"],

      suffixes: ["heart", "soul", "blade", "spirit", "storm", "fire", "wind", "star", "light", "shadow"]

    },

    tech: {

      prefixes: ["Cyber", "Data", "Eon", "Flux", "Grid", "Helix", "Ion", "Jet", "Kiln", "Loop"],

      suffixes: ["tech", "tron", "byte", "flux", "grid", "sync", "link", "core", "node", "wave"]

    },

    nature: {

      prefixes: ["Aurora", "Brook", "Cloud", "Dew", "Echo", "Fern", "Gale", "Hazel", "Iris", "Jade"],

      suffixes: ["leaf", "river", "wood", "meadow", "valley", "grove", "field", "garden", "brook", "hill"]

    }

  };

  const category = arg[0]?.toLowerCase() || "fantasy";

  const count = Math.min(parseInt(arg[1]) || 1, 5);

  try {

    if (!categories[category]) {

      throw new Error(`Cat√©gorie invalide. Choisissez parmi: ${Object.keys(categories).join(", ")}`);

    }

    const names = Array(count).fill(0).map(() => {

      const prefix = utils.randomFromArray(categories[category].prefixes);

      const suffix = utils.randomFromArray(categories[category].suffixes);

      return `${prefix}${suffix}`;

    });

    const response = utils.formatResponse("G√©n√©rateur de Noms",

      `üé≠ Cat√©gorie: ${category}\n\n` +

      names.map((name, i) => `${i + 1}. ${name}`).join("\n")

    );

    repondre(response);

  } catch (error) {

    repondre(`‚ùå Erreur: ${error.message}`);

  }

});

// Commande Echo am√©lior√©e

zokou({

  nomCom: "echo",

  categorie: "FAMOUS-TECH-PLUGINSüá≠üáπ",

  reaction: "üîÅ",

  desc: "R√©p√®te un texte avec formatage personnalis√©.",

  alias: ["repeat"]

}, async (origineMessage, zk, commandeOptions) => {

  const { arg, repondre } = commandeOptions;

  if (!arg[0] || !arg[1]) {

    return repondre("‚ùå Usage: .echo <nombre> <texte> [format?]");

  }

  try {

    const count = parseInt(arg[0]);

    const text = arg.slice(1).join(" ");

    const format = arg.includes("--format") ? arg[arg.indexOf("--format") + 1] : "normal";

    utils.validateInput(String(count), /^\d+$/, "Nombre invalide");

    if (count > 50) throw new Error("Maximum 50 r√©p√©titions");

    let formattedText;

    switch (format) {

      case "numbered":

        formattedText = Array(count).fill(text).map((t, i) => `${i + 1}. ${t}`).join("\n");

        break;

      case "bullet":

        formattedText = Array(count).fill(text).map(t => `‚Ä¢ ${t}`).join("\n");

        break;

      case "spaced":

        formattedText = Array(count).fill(text).join("\n\n");

        break;

      default:

        formattedText = Array(count).fill(text).join("\n");

    }

    const response = utils.formatResponse("Echo",

      `üîÑ R√©p√©titions: ${count}\n` +

      `üìù Format: ${format}\n\n` +

      formattedText

    );

    repondre(response);

  } catch (error) {

    repondre(`‚ùå Erreur: ${error.message}`);

  }

});

// G√©n√©rateur de CV am√©lior√©

zokou({

  nomCom: "gencv",

  categorie: "FAMOUS-TECH-PLUGINSüá≠üáπ",

  reaction: "üìÑ",

  desc: "G√©n√®re un CV professionnel personnalis√©.",

  alias: ["genresume"]

}, async (origineMessage, zk, commandeOptions) => {

  const { arg, repondre, nomAuteurMessage } = commandeOptions;

  if (arg.length < 3) {

    return repondre("‚ùå Usage: .gencv <domaine> <ann√©es_exp> <comp√©tences>");

  }

  try {

    const domain = arg[0];

    const experience = parseInt(arg[1]);

    const skills = arg.slice(2).join(" ").split(",").map(s => s.trim());

    utils.validateInput(domain, /^[a-zA-Z\s-]+$/, "Domaine invalide");

    if (experience < 0 || experience > 50) throw new Error("Ann√©es d'exp√©rience invalides");

    const cvTemplate = {

      junior: {

        titles: ["D√©veloppeur Junior", "Analyste Junior", "Designer Junior"],

        companies: ["StartupTech", "InnovCorp", "TechFlow"],

        responsibilities: [

          "D√©veloppement de fonctionnalit√©s",

          "Tests et debugging",

          "Documentation technique"

        ]

      },

      senior: {

        titles: ["D√©veloppeur Senior", "Architecte Solution", "Lead Developer"],

        companies: ["MegaTech", "GlobalSoft", "TechGiant"],

        responsibilities: [

          "Architecture de solutions",

          "Management d'√©quipe",

          "Optimisation des processus"

        ]

      }

    };

    const level = experience < 5 ? "junior" : "senior";

    const template = cvTemplate[level];

    const cv = utils.formatResponse("Curriculum Vitae",

      `üë§ *${nomAuteurMessage}*\n` +

      `üíº ${utils.randomFromArray(template.titles)} en ${domain}\n\n` +

      `üìö Formation\n` +

      `‚Ä¢ Master en ${domain}, Universit√© Tech\n` +

      `‚Ä¢ Certifications professionnelles\n\n` +

      `üí° Exp√©rience (${experience} ans)\n` +

      template.companies.slice(0, 2).map(company => 

        `‚Ä¢ ${company}\n  ${utils.randomFromArray(template.responsibilities)}`

      ).join("\n") + "\n\n" +

      `üîß Comp√©tences\n${skills.map(s => `‚Ä¢ ${s}`).join("\n")}\n\n` +

      `üìû Contact\n‚Ä¢ Email: professionnel@email.com\n‚Ä¢ LinkedIn: linkedin.com/in/profile`

    );

    repondre(cv);

  } catch (error) {

    repondre(`‚ùå Erreur: ${error.message}`);

  }

});

// G√©n√©rateur de noms d'entreprise am√©lior√©

zokou({

  nomCom: "genbusiness_name",

  categorie: "FAMOUS-TECH-PLUGINSüá≠üáπ",

  reaction: "üè¢",

  desc: "G√©n√®re des noms d'entreprise cr√©atifs.",

  alias: ["genbizname"]

}, async (origineMessage, zk, commandeOptions) => {

  const { arg, repondre } = commandeOptions;

  if (!arg[0]) {

    return repondre("‚ùå Veuillez sp√©cifier un secteur d'activit√©.");

  }

  const sector = arg[0].toLowerCase();

  

  const businessNames = {

    tech: {

      prefixes: ["Quantum", "Cyber", "Digital", "Smart", "Tech", "Future", "Net", "Data", "Cloud", "AI"],

      suffixes: ["Labs", "Solutions", "Systems", "Tech", "Logic", "Sphere", "Hub", "Core", "Wave", "Mind"],

      formats: [

        (p, s) => `${p}${s}`,

        (p, s) => `${p}-${s}`,

        (p, s) => `${p}.io`,

        (p, s) => `${p}${s}.ai`

      ]

    },

    finance: {

      prefixes: ["Capital", "Wealth", "Asset", "Fund", "Trade", "Money", "Finance", "Credit", "Cash", "Bank"],

      suffixes: ["Plus", "Group", "Partners", "Global", "Trust", "Link", "Wise", "Worth", "Safe", "Pro"],

      formats: [

        (p, s) => `${p}${s}`,

        (p, s) => `${p} ${s}`,

        (p, s) => `${p}First`,

        (p, s) => `${p}360`

      ]

    },

    health: {

      prefixes: ["Vital", "Care", "Health", "Med", "Life", "Cure", "Well", "Bio", "Heal", "Safe"],

      suffixes: ["Care", "Health", "Life", "Plus", "Med", "Fix", "Aid", "Path", "Way", "Zone"],

      formats: [

        (p, s) => `${p}${s}`,

        (p, s) => `${p}-${s}`,

        (p, s) => `${p}4Life`,

        (p, s) => `${p}Express`

      ]

    }

  };

  try {

    if (!businessNames[sector]) {

      throw new Error(`Secteur non reconnu. Choisissez parmi: ${Object.keys(businessNames[sector]).join(", ")}`);

    }

    const { prefixes, suffixes, formats } = businessNames[sector];

    const names = Array(3).fill(0).map(() => {

      const prefix = utils.randomFromArray(prefixes);

      const suffix = utils.randomFromArray(suffixes);

      const format = utils.randomFromArray(formats);

      return format(prefix, suffix);

    });

    const response = utils.formatResponse("G√©n√©rateur de Noms d'Entreprise",

      `üè¢ Secteur: ${sector}\n\n` +

      names.map((name, i) => `${i + 1}. ${name}`).join("\n") + "\n\n" +

      `üí° Ces noms sont g√©n√©r√©s al√©atoirement.\n` +

      `‚ö†Ô∏è V√©rifiez la disponibilit√© avant utilisation.`

    );

    repondre(response);

  } catch (error) {

    repondre(`‚ùå Erreur: ${error.message}`);

  }

});

// Commande m√©t√©o am√©lior√©e

zokou({

  nomCom: "meteo",

  categorie: "FAMOUS-TECH-PLUGINSüá≠üáπ",

  reaction: "üå§Ô∏è",

  desc: "Fournit des informations m√©t√©orologiques d√©taill√©es.",

  alias: ["weather"]

}, async (origineMessage, zk, commandeOptions) => {

  const { arg, repondre } = commandeOptions;

  if (!arg[0]) {

    return repondre("‚ùå Veuillez sp√©cifier une ville.");

  }

  const ville = arg.join(" ");

  try {

    // G√©ocodage

    const geocodeURL = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(ville)}&count=1&language=fr`;

    const geocodeResponse = await axios.get(geocodeURL);

    if (!geocodeResponse.data.results?.length) {

      throw new Error(`Ville non trouv√©e: ${ville}`);

    }

    const { latitude, longitude, name, country } = geocodeResponse.data.results[0];

    // R√©cup√©ration m√©t√©o

    const weatherURL = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true&timezone=auto&daily=temperature_2m_max,temperature_2m_min,precipitation_probability_max,windspeed_10m_max`;

    const weatherResponse = await axios.get(weatherURL);

    const weather = weatherResponse.data;

    const response = utils.formatResponse("M√©t√©o",

      `üìç *${name}, ${country}*\n\n` +

      `üå°Ô∏è Temp√©rature actuelle: ${weather.current_weather.temperature}¬∞C\n` +

      `üå™Ô∏è Vent: ${weather.current_weather.windspeed} km/h\n` +

      `üå§Ô∏è Conditions: ${getWeatherDescription(weather.current_weather.weathercode)}\n\n` +

      `üìä Pr√©visions aujourd'hui:\n` +

      `‚Ä¢ Max: ${weather.daily.temperature_2m_max[0]}¬∞C\n` +

      `‚Ä¢ Min: ${weather.daily.temperature_2m_min[0]}¬∞C\n` +

      `‚Ä¢ Probabilit√© de pluie: ${weather.daily.precipitation_probability_max[0]}%\n` +

      `‚Ä¢ Vent max: ${weather.daily.windspeed_10m_max[0]} km/h\n\n` +

      `‚è∞ Mise √† jour: ${new Date(weather.current_weather.time).toLocaleString()}`

    );

    repondre(response);

  } catch (error) {

    const errorMsg = error.response?.status ? handleWeatherAPIError(error) : error.message;

    repondre(`‚ùå Erreur: ${errorMsg}`);

  }

});

// Commande des messages d'amour am√©lior√©e

zokou({

  nomCom: "love_msg",

  categorie: "FAMOUS-TECH-PLUGINSüá≠üáπ",

  reaction: "‚ù§Ô∏è",

  desc: "G√©n√®re des messages d'amour personnalis√©s.",

  alias: ["lovemsg"]

}, async (origineMessage, zk, commandeOptions) => {

  const { arg, repondre } = commandeOptions;

  if (!arg[0]) {

    return repondre("‚ùå Usage: .love_msg <genre> [style: po√©tique/simple/dr√¥le]");

  }

  try {

    const genre = arg[0].toLowerCase();

    const style = arg[1]?.toLowerCase() || "simple";

    const messages = {

      fille: {

        po√©tique: [

          "Ton amour est comme un jardin de roses √©ternelles, chaque p√©tale conte notre histoire.",

          "Dans l'oc√©an de mes pens√©es, tu es la plus belle des sir√®nes.",

          "Tes yeux sont les √©toiles qui guident mon chemin dans la nuit."

        ],

        simple: [

          "Tu es la plus belle chose qui me soit arriv√©e.",

          "Chaque jour pass√© avec toi est un cadeau pr√©cieux.",

          "Tu illumines ma vie par ta simple pr√©sence."

        ],

        dr√¥le: [

          "Si tu √©tais une pizza, tu serais ma pr√©f√©r√©e ! üçï",

          "Es-tu un ange ? Car tu as fait chavirer mon c≈ìur ! üòá",

          "Tu es comme le WiFi - je ne peux pas vivre sans toi ! üì∂"

        ]

      },

      gar√ßon: {

        po√©tique: [

          "Tu es le h√©ros de mon histoire d'amour, le prince de mes r√™ves.",

          "Dans le livre de ma vie, tu es le plus beau chapitre.",

          "Ton amour est mon refuge, mon havre de paix."

        ],

        simple: [

          "Tu es l'homme de ma vie, mon roc, mon tout.",

          "Avec toi, chaque moment devient magique.",

          "Tu es mon bonheur quotidien."

        ],

        dr√¥le: [

          "Tu es comme mon caf√© du matin - impossible de commencer la journ√©e sans toi ! ‚òï",

          "Es-tu Superman ? Car tu as des super-pouvoirs sur mon c≈ìur ! ü¶∏‚Äç‚ôÇÔ∏è",

          "Si tu √©tais un jeu vid√©o, tu serais mon pr√©f√©r√© ! üéÆ"

        ]

      }

    };

    if (!messages[genre]) {

      throw new Error("Genre non reconnu. Choisissez 'fille' ou 'gar√ßon'");

    }

    if (!messages[genre][style]) {

      throw new Error("Style non reconnu. Choisissez 'po√©tique', 'simple' ou 'dr√¥le'");

    }

    const selectedMessages = messages[genre][style];

    const message = utils.randomFromArray(selectedMessages);

    const response = utils.formatResponse("Message d'Amour",

      `üíù Genre: ${genre}\n` +

      `‚ú® Style: ${style}\n\n` +

      `${message}`

    );

    repondre(response);

  } catch (error) {

    repondre(`‚ùå Erreur: ${error.message}`);

  }

});

// Commande d'auteur am√©lior√©e

zokou({

  nomCom: "famous-tech",

  categorie: "FAMOUS-TECH-PLUGINSüá≠üáπ",

  reaction: "üí´",

  desc: "Informations sur l'auteur et le projet.",

  alias: ["ft"]

}, async (origineMessage, zk, commandeOptions) => {

  const { repondre } = commandeOptions;

  const response = utils.formatResponse("Famous Tech",

    `üë®‚Äçüíª *Cr√©ateur*\n` +

    `‚Ä¢ Nom: Famous Tech\n` +

    `‚Ä¢ R√¥le: Collaborateur externe\n\n` +

    `üì± *Contact*\n` +

    `‚Ä¢ WhatsApp: +50943782508\n` +

    `‚Ä¢ Email: famoustechht@gmail.com\n\n` +

    `üåê *Sites Web*\n` +

    `‚Ä¢ Mon groupe: https://famous-tech-group.vercel.app\n` +

    `‚Ä¢ Blog: https://famous-tech-blog.vercel.app\n\n` +

    `üì¶ *Projet*\n` +

    `‚Ä¢ Nom de cat√©gorie: FAMOUS-TECH-PLUGINS\n` +

    `‚Ä¢ Version: 2.0.0\n` +

    `‚Ä¢ Licence: MIT\n\n` +

    `üí° *Support*\n` +

    `Pour toute question ou suggestion, n'h√©sitez pas √† me contacter !`

  );

  repondre(response);

});

// Fonctions utilitaires suppl√©mentaires

function handleWeatherAPIError(error) {

  const errorCodes = {

    400: "Requ√™te invalide. V√©rifiez les coordonn√©es.",

    401: "Erreur d'authentification API.",

    403: "Acc√®s refus√© √† l'API.",

    404: "Donn√©es m√©t√©o non trouv√©es.",

    429: "Trop de requ√™tes. R√©essayez plus tard.",

    500: "Erreur serveur de l'API m√©t√©o.",

    502: "API m√©t√©o temporairement indisponible.",

    503: "Service m√©t√©o indisponible.",

    504: "D√©lai d'attente d√©pass√©."

  };

  return errorCodes[error.response.status] || `Erreur inattendue: ${error.response.status}`;

}

function getWeatherDescription(code) {
  const descriptions = {
    0: "‚òÄÔ∏è Ciel d√©gag√©",
    1: "üå§Ô∏è Peu nuageux",
    2: "‚õÖ Partiellement nuageux",
    3: "‚òÅÔ∏è Nuageux",
    45: "üå´Ô∏è Brouillard",
    48: "üå´Ô∏è Brouillard givrant",
    51: "üåßÔ∏è Bruine l√©g√®re",
    53: "üåßÔ∏è Bruine mod√©r√©e",
    55: "üåßÔ∏è Bruine dense",
    56: "üåßÔ∏è Bruine vergla√ßante",
    57: "üåßÔ∏è Bruine vergla√ßante dense",
    61: "üåßÔ∏è Pluie l√©g√®re",
    63: "üåßÔ∏è Pluie mod√©r√©e",
    65: "üåßÔ∏è Pluie forte",
    66: "üåßÔ∏è Pluie vergla√ßante",
    67: "üåßÔ∏è Pluie vergla√ßante forte",
    71: "üå®Ô∏è Neige l√©g√®re",
    73: "üå®Ô∏è Neige mod√©r√©e",
    75: "üå®Ô∏è Neige forte",
    77: "‚ùÑÔ∏è Grains de neige",
    80: "üå¶Ô∏è Averses l√©g√®res",
    81: "üå¶Ô∏è Averses mod√©r√©es",
    82: "üå¶Ô∏è Averses violentes",
    85: "üå®Ô∏è Averses de neige",
    86: "üå®Ô∏è Fortes averses de neige",
    95: "‚õàÔ∏è Orage",
    96: "‚õàÔ∏è Orage avec gr√™le",
    99: "‚õàÔ∏è Orage violent avec gr√™le"
  };
  
  return descriptions[code] || "Conditions inconnues";
}
        
